/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck
/*
 * This file exports the `Poem` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from '@prisma/client/runtime/client';
import type * as $Enums from '../enums.ts';
import type * as Prisma from '../internal/prismaNamespace.ts';

/**
 * Model Poem
 *
 */
export type PoemModel =
	runtime.Types.Result.DefaultSelection<Prisma.$PoemPayload>;

export type AggregatePoem = {
	_count: PoemCountAggregateOutputType | null;
	_avg: PoemAvgAggregateOutputType | null;
	_sum: PoemSumAggregateOutputType | null;
	_min: PoemMinAggregateOutputType | null;
	_max: PoemMaxAggregateOutputType | null;
};

export type PoemAvgAggregateOutputType = {
	id: number | null;
	toUserId: number | null;
	toPoemId: number | null;
	authorId: number | null;
};

export type PoemSumAggregateOutputType = {
	id: number | null;
	toUserId: number | null;
	toPoemId: number | null;
	authorId: number | null;
};

export type PoemMinAggregateOutputType = {
	id: number | null;
	title: string | null;
	slug: string | null;
	excerpt: string | null;
	content: string | null;
	isCommentable: boolean | null;
	toUserId: number | null;
	toPoemId: number | null;
	status: $Enums.poemStatus | null;
	visibility: $Enums.poemVisibility | null;
	moderationStatus: $Enums.poemModerationStatus | null;
	createdAt: Date | null;
	updatedAt: Date | null;
	deletedAt: Date | null;
	authorId: number | null;
};

export type PoemMaxAggregateOutputType = {
	id: number | null;
	title: string | null;
	slug: string | null;
	excerpt: string | null;
	content: string | null;
	isCommentable: boolean | null;
	toUserId: number | null;
	toPoemId: number | null;
	status: $Enums.poemStatus | null;
	visibility: $Enums.poemVisibility | null;
	moderationStatus: $Enums.poemModerationStatus | null;
	createdAt: Date | null;
	updatedAt: Date | null;
	deletedAt: Date | null;
	authorId: number | null;
};

export type PoemCountAggregateOutputType = {
	id: number;
	title: number;
	slug: number;
	excerpt: number;
	content: number;
	isCommentable: number;
	toUserId: number;
	toPoemId: number;
	status: number;
	visibility: number;
	moderationStatus: number;
	createdAt: number;
	updatedAt: number;
	deletedAt: number;
	authorId: number;
	_all: number;
};

export type PoemAvgAggregateInputType = {
	id?: true;
	toUserId?: true;
	toPoemId?: true;
	authorId?: true;
};

export type PoemSumAggregateInputType = {
	id?: true;
	toUserId?: true;
	toPoemId?: true;
	authorId?: true;
};

export type PoemMinAggregateInputType = {
	id?: true;
	title?: true;
	slug?: true;
	excerpt?: true;
	content?: true;
	isCommentable?: true;
	toUserId?: true;
	toPoemId?: true;
	status?: true;
	visibility?: true;
	moderationStatus?: true;
	createdAt?: true;
	updatedAt?: true;
	deletedAt?: true;
	authorId?: true;
};

export type PoemMaxAggregateInputType = {
	id?: true;
	title?: true;
	slug?: true;
	excerpt?: true;
	content?: true;
	isCommentable?: true;
	toUserId?: true;
	toPoemId?: true;
	status?: true;
	visibility?: true;
	moderationStatus?: true;
	createdAt?: true;
	updatedAt?: true;
	deletedAt?: true;
	authorId?: true;
};

export type PoemCountAggregateInputType = {
	id?: true;
	title?: true;
	slug?: true;
	excerpt?: true;
	content?: true;
	isCommentable?: true;
	toUserId?: true;
	toPoemId?: true;
	status?: true;
	visibility?: true;
	moderationStatus?: true;
	createdAt?: true;
	updatedAt?: true;
	deletedAt?: true;
	authorId?: true;
	_all?: true;
};

export type PoemAggregateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Poem to aggregate.
	 */
	where?: Prisma.PoemWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Poems to fetch.
	 */
	orderBy?:
		| Prisma.PoemOrderByWithRelationInput
		| Prisma.PoemOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the start position
	 */
	cursor?: Prisma.PoemWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Poems from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Poems.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Count returned Poems
	 **/
	_count?: true | PoemCountAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to average
	 **/
	_avg?: PoemAvgAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to sum
	 **/
	_sum?: PoemSumAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the minimum value
	 **/
	_min?: PoemMinAggregateInputType;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
	 *
	 * Select which fields to find the maximum value
	 **/
	_max?: PoemMaxAggregateInputType;
};

export type GetPoemAggregateType<T extends PoemAggregateArgs> = {
	[P in keyof T & keyof AggregatePoem]: P extends '_count' | 'count'
		? T[P] extends true
			? number
			: Prisma.GetScalarType<T[P], AggregatePoem[P]>
		: Prisma.GetScalarType<T[P], AggregatePoem[P]>;
};

export type PoemGroupByArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.PoemWhereInput;
	orderBy?:
		| Prisma.PoemOrderByWithAggregationInput
		| Prisma.PoemOrderByWithAggregationInput[];
	by: Prisma.PoemScalarFieldEnum[] | Prisma.PoemScalarFieldEnum;
	having?: Prisma.PoemScalarWhereWithAggregatesInput;
	take?: number;
	skip?: number;
	_count?: PoemCountAggregateInputType | true;
	_avg?: PoemAvgAggregateInputType;
	_sum?: PoemSumAggregateInputType;
	_min?: PoemMinAggregateInputType;
	_max?: PoemMaxAggregateInputType;
};

export type PoemGroupByOutputType = {
	id: number;
	title: string;
	slug: string;
	excerpt: string | null;
	content: string;
	isCommentable: boolean;
	toUserId: number | null;
	toPoemId: number | null;
	status: $Enums.poemStatus;
	visibility: $Enums.poemVisibility;
	moderationStatus: $Enums.poemModerationStatus;
	createdAt: Date;
	updatedAt: Date;
	deletedAt: Date | null;
	authorId: number;
	_count: PoemCountAggregateOutputType | null;
	_avg: PoemAvgAggregateOutputType | null;
	_sum: PoemSumAggregateOutputType | null;
	_min: PoemMinAggregateOutputType | null;
	_max: PoemMaxAggregateOutputType | null;
};

type GetPoemGroupByPayload<T extends PoemGroupByArgs> = Prisma.PrismaPromise<
	Array<
		Prisma.PickEnumerable<PoemGroupByOutputType, T['by']> & {
			[P in keyof T & keyof PoemGroupByOutputType]: P extends '_count'
				? T[P] extends boolean
					? number
					: Prisma.GetScalarType<T[P], PoemGroupByOutputType[P]>
				: Prisma.GetScalarType<T[P], PoemGroupByOutputType[P]>;
		}
	>
>;

export type PoemWhereInput = {
	AND?: Prisma.PoemWhereInput | Prisma.PoemWhereInput[];
	OR?: Prisma.PoemWhereInput[];
	NOT?: Prisma.PoemWhereInput | Prisma.PoemWhereInput[];
	id?: Prisma.IntFilter<'Poem'> | number;
	title?: Prisma.StringFilter<'Poem'> | string;
	slug?: Prisma.StringFilter<'Poem'> | string;
	excerpt?: Prisma.StringNullableFilter<'Poem'> | string | null;
	content?: Prisma.StringFilter<'Poem'> | string;
	isCommentable?: Prisma.BoolFilter<'Poem'> | boolean;
	toUserId?: Prisma.IntNullableFilter<'Poem'> | number | null;
	toPoemId?: Prisma.IntNullableFilter<'Poem'> | number | null;
	status?: Prisma.EnumpoemStatusFilter<'Poem'> | $Enums.poemStatus;
	visibility?: Prisma.EnumpoemVisibilityFilter<'Poem'> | $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFilter<'Poem'>
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFilter<'Poem'> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<'Poem'> | Date | string;
	deletedAt?: Prisma.DateTimeNullableFilter<'Poem'> | Date | string | null;
	authorId?: Prisma.IntFilter<'Poem'> | number;
	toUser?: Prisma.XOR<
		Prisma.UserNullableScalarRelationFilter,
		Prisma.UserWhereInput
	> | null;
	toPoem?: Prisma.XOR<
		Prisma.PoemNullableScalarRelationFilter,
		Prisma.PoemWhereInput
	> | null;
	dedications?: Prisma.PoemListRelationFilter;
	tags?: Prisma.TagListRelationFilter;
	author?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
	comments?: Prisma.CommentListRelationFilter;
	poemLikes?: Prisma.PoemLikeListRelationFilter;
};

export type PoemOrderByWithRelationInput = {
	id?: Prisma.SortOrder;
	title?: Prisma.SortOrder;
	slug?: Prisma.SortOrder;
	excerpt?: Prisma.SortOrderInput | Prisma.SortOrder;
	content?: Prisma.SortOrder;
	isCommentable?: Prisma.SortOrder;
	toUserId?: Prisma.SortOrderInput | Prisma.SortOrder;
	toPoemId?: Prisma.SortOrderInput | Prisma.SortOrder;
	status?: Prisma.SortOrder;
	visibility?: Prisma.SortOrder;
	moderationStatus?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	deletedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	authorId?: Prisma.SortOrder;
	toUser?: Prisma.UserOrderByWithRelationInput;
	toPoem?: Prisma.PoemOrderByWithRelationInput;
	dedications?: Prisma.PoemOrderByRelationAggregateInput;
	tags?: Prisma.TagOrderByRelationAggregateInput;
	author?: Prisma.UserOrderByWithRelationInput;
	comments?: Prisma.CommentOrderByRelationAggregateInput;
	poemLikes?: Prisma.PoemLikeOrderByRelationAggregateInput;
};

export type PoemWhereUniqueInput = Prisma.AtLeast<
	{
		id?: number;
		authorId_slug?: Prisma.PoemAuthorIdSlugCompoundUniqueInput;
		AND?: Prisma.PoemWhereInput | Prisma.PoemWhereInput[];
		OR?: Prisma.PoemWhereInput[];
		NOT?: Prisma.PoemWhereInput | Prisma.PoemWhereInput[];
		title?: Prisma.StringFilter<'Poem'> | string;
		slug?: Prisma.StringFilter<'Poem'> | string;
		excerpt?: Prisma.StringNullableFilter<'Poem'> | string | null;
		content?: Prisma.StringFilter<'Poem'> | string;
		isCommentable?: Prisma.BoolFilter<'Poem'> | boolean;
		toUserId?: Prisma.IntNullableFilter<'Poem'> | number | null;
		toPoemId?: Prisma.IntNullableFilter<'Poem'> | number | null;
		status?: Prisma.EnumpoemStatusFilter<'Poem'> | $Enums.poemStatus;
		visibility?:
			| Prisma.EnumpoemVisibilityFilter<'Poem'>
			| $Enums.poemVisibility;
		moderationStatus?:
			| Prisma.EnumpoemModerationStatusFilter<'Poem'>
			| $Enums.poemModerationStatus;
		createdAt?: Prisma.DateTimeFilter<'Poem'> | Date | string;
		updatedAt?: Prisma.DateTimeFilter<'Poem'> | Date | string;
		deletedAt?: Prisma.DateTimeNullableFilter<'Poem'> | Date | string | null;
		authorId?: Prisma.IntFilter<'Poem'> | number;
		toUser?: Prisma.XOR<
			Prisma.UserNullableScalarRelationFilter,
			Prisma.UserWhereInput
		> | null;
		toPoem?: Prisma.XOR<
			Prisma.PoemNullableScalarRelationFilter,
			Prisma.PoemWhereInput
		> | null;
		dedications?: Prisma.PoemListRelationFilter;
		tags?: Prisma.TagListRelationFilter;
		author?: Prisma.XOR<Prisma.UserScalarRelationFilter, Prisma.UserWhereInput>;
		comments?: Prisma.CommentListRelationFilter;
		poemLikes?: Prisma.PoemLikeListRelationFilter;
	},
	'id' | 'authorId_slug'
>;

export type PoemOrderByWithAggregationInput = {
	id?: Prisma.SortOrder;
	title?: Prisma.SortOrder;
	slug?: Prisma.SortOrder;
	excerpt?: Prisma.SortOrderInput | Prisma.SortOrder;
	content?: Prisma.SortOrder;
	isCommentable?: Prisma.SortOrder;
	toUserId?: Prisma.SortOrderInput | Prisma.SortOrder;
	toPoemId?: Prisma.SortOrderInput | Prisma.SortOrder;
	status?: Prisma.SortOrder;
	visibility?: Prisma.SortOrder;
	moderationStatus?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	deletedAt?: Prisma.SortOrderInput | Prisma.SortOrder;
	authorId?: Prisma.SortOrder;
	_count?: Prisma.PoemCountOrderByAggregateInput;
	_avg?: Prisma.PoemAvgOrderByAggregateInput;
	_max?: Prisma.PoemMaxOrderByAggregateInput;
	_min?: Prisma.PoemMinOrderByAggregateInput;
	_sum?: Prisma.PoemSumOrderByAggregateInput;
};

export type PoemScalarWhereWithAggregatesInput = {
	AND?:
		| Prisma.PoemScalarWhereWithAggregatesInput
		| Prisma.PoemScalarWhereWithAggregatesInput[];
	OR?: Prisma.PoemScalarWhereWithAggregatesInput[];
	NOT?:
		| Prisma.PoemScalarWhereWithAggregatesInput
		| Prisma.PoemScalarWhereWithAggregatesInput[];
	id?: Prisma.IntWithAggregatesFilter<'Poem'> | number;
	title?: Prisma.StringWithAggregatesFilter<'Poem'> | string;
	slug?: Prisma.StringWithAggregatesFilter<'Poem'> | string;
	excerpt?: Prisma.StringNullableWithAggregatesFilter<'Poem'> | string | null;
	content?: Prisma.StringWithAggregatesFilter<'Poem'> | string;
	isCommentable?: Prisma.BoolWithAggregatesFilter<'Poem'> | boolean;
	toUserId?: Prisma.IntNullableWithAggregatesFilter<'Poem'> | number | null;
	toPoemId?: Prisma.IntNullableWithAggregatesFilter<'Poem'> | number | null;
	status?:
		| Prisma.EnumpoemStatusWithAggregatesFilter<'Poem'>
		| $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityWithAggregatesFilter<'Poem'>
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusWithAggregatesFilter<'Poem'>
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeWithAggregatesFilter<'Poem'> | Date | string;
	updatedAt?: Prisma.DateTimeWithAggregatesFilter<'Poem'> | Date | string;
	deletedAt?:
		| Prisma.DateTimeNullableWithAggregatesFilter<'Poem'>
		| Date
		| string
		| null;
	authorId?: Prisma.IntWithAggregatesFilter<'Poem'> | number;
};

export type PoemCreateInput = {
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	toUser?: Prisma.UserCreateNestedOneWithoutFromPoemDedicationsInput;
	toPoem?: Prisma.PoemCreateNestedOneWithoutDedicationsInput;
	dedications?: Prisma.PoemCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagCreateNestedManyWithoutPoemsInput;
	author: Prisma.UserCreateNestedOneWithoutPoemsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeCreateNestedManyWithoutPoemInput;
};

export type PoemUncheckedCreateInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toUserId?: number | null;
	toPoemId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	authorId: number;
	dedications?: Prisma.PoemUncheckedCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagUncheckedCreateNestedManyWithoutPoemsInput;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeUncheckedCreateNestedManyWithoutPoemInput;
};

export type PoemUpdateInput = {
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	toUser?: Prisma.UserUpdateOneWithoutFromPoemDedicationsNestedInput;
	toPoem?: Prisma.PoemUpdateOneWithoutDedicationsNestedInput;
	dedications?: Prisma.PoemUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUpdateManyWithoutPoemsNestedInput;
	author?: Prisma.UserUpdateOneRequiredWithoutPoemsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toUserId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	toPoemId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	authorId?: Prisma.IntFieldUpdateOperationsInput | number;
	dedications?: Prisma.PoemUncheckedUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUncheckedUpdateManyWithoutPoemsNestedInput;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUncheckedUpdateManyWithoutPoemNestedInput;
};

export type PoemCreateManyInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toUserId?: number | null;
	toPoemId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	authorId: number;
};

export type PoemUpdateManyMutationInput = {
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
};

export type PoemUncheckedUpdateManyInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toUserId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	toPoemId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	authorId?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type PoemListRelationFilter = {
	every?: Prisma.PoemWhereInput;
	some?: Prisma.PoemWhereInput;
	none?: Prisma.PoemWhereInput;
};

export type PoemOrderByRelationAggregateInput = {
	_count?: Prisma.SortOrder;
};

export type PoemScalarRelationFilter = {
	is?: Prisma.PoemWhereInput;
	isNot?: Prisma.PoemWhereInput;
};

export type PoemNullableScalarRelationFilter = {
	is?: Prisma.PoemWhereInput | null;
	isNot?: Prisma.PoemWhereInput | null;
};

export type PoemAuthorIdSlugCompoundUniqueInput = {
	authorId: number;
	slug: string;
};

export type PoemCountOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	title?: Prisma.SortOrder;
	slug?: Prisma.SortOrder;
	excerpt?: Prisma.SortOrder;
	content?: Prisma.SortOrder;
	isCommentable?: Prisma.SortOrder;
	toUserId?: Prisma.SortOrder;
	toPoemId?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	visibility?: Prisma.SortOrder;
	moderationStatus?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	deletedAt?: Prisma.SortOrder;
	authorId?: Prisma.SortOrder;
};

export type PoemAvgOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	toUserId?: Prisma.SortOrder;
	toPoemId?: Prisma.SortOrder;
	authorId?: Prisma.SortOrder;
};

export type PoemMaxOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	title?: Prisma.SortOrder;
	slug?: Prisma.SortOrder;
	excerpt?: Prisma.SortOrder;
	content?: Prisma.SortOrder;
	isCommentable?: Prisma.SortOrder;
	toUserId?: Prisma.SortOrder;
	toPoemId?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	visibility?: Prisma.SortOrder;
	moderationStatus?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	deletedAt?: Prisma.SortOrder;
	authorId?: Prisma.SortOrder;
};

export type PoemMinOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	title?: Prisma.SortOrder;
	slug?: Prisma.SortOrder;
	excerpt?: Prisma.SortOrder;
	content?: Prisma.SortOrder;
	isCommentable?: Prisma.SortOrder;
	toUserId?: Prisma.SortOrder;
	toPoemId?: Prisma.SortOrder;
	status?: Prisma.SortOrder;
	visibility?: Prisma.SortOrder;
	moderationStatus?: Prisma.SortOrder;
	createdAt?: Prisma.SortOrder;
	updatedAt?: Prisma.SortOrder;
	deletedAt?: Prisma.SortOrder;
	authorId?: Prisma.SortOrder;
};

export type PoemSumOrderByAggregateInput = {
	id?: Prisma.SortOrder;
	toUserId?: Prisma.SortOrder;
	toPoemId?: Prisma.SortOrder;
	authorId?: Prisma.SortOrder;
};

export type PoemCreateNestedManyWithoutAuthorInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutAuthorInput,
				Prisma.PoemUncheckedCreateWithoutAuthorInput
		  >
		| Prisma.PoemCreateWithoutAuthorInput[]
		| Prisma.PoemUncheckedCreateWithoutAuthorInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutAuthorInput
		| Prisma.PoemCreateOrConnectWithoutAuthorInput[];
	createMany?: Prisma.PoemCreateManyAuthorInputEnvelope;
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
};

export type PoemCreateNestedManyWithoutToUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutToUserInput,
				Prisma.PoemUncheckedCreateWithoutToUserInput
		  >
		| Prisma.PoemCreateWithoutToUserInput[]
		| Prisma.PoemUncheckedCreateWithoutToUserInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutToUserInput
		| Prisma.PoemCreateOrConnectWithoutToUserInput[];
	createMany?: Prisma.PoemCreateManyToUserInputEnvelope;
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
};

export type PoemUncheckedCreateNestedManyWithoutAuthorInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutAuthorInput,
				Prisma.PoemUncheckedCreateWithoutAuthorInput
		  >
		| Prisma.PoemCreateWithoutAuthorInput[]
		| Prisma.PoemUncheckedCreateWithoutAuthorInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutAuthorInput
		| Prisma.PoemCreateOrConnectWithoutAuthorInput[];
	createMany?: Prisma.PoemCreateManyAuthorInputEnvelope;
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
};

export type PoemUncheckedCreateNestedManyWithoutToUserInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutToUserInput,
				Prisma.PoemUncheckedCreateWithoutToUserInput
		  >
		| Prisma.PoemCreateWithoutToUserInput[]
		| Prisma.PoemUncheckedCreateWithoutToUserInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutToUserInput
		| Prisma.PoemCreateOrConnectWithoutToUserInput[];
	createMany?: Prisma.PoemCreateManyToUserInputEnvelope;
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
};

export type PoemUpdateManyWithoutAuthorNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutAuthorInput,
				Prisma.PoemUncheckedCreateWithoutAuthorInput
		  >
		| Prisma.PoemCreateWithoutAuthorInput[]
		| Prisma.PoemUncheckedCreateWithoutAuthorInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutAuthorInput
		| Prisma.PoemCreateOrConnectWithoutAuthorInput[];
	upsert?:
		| Prisma.PoemUpsertWithWhereUniqueWithoutAuthorInput
		| Prisma.PoemUpsertWithWhereUniqueWithoutAuthorInput[];
	createMany?: Prisma.PoemCreateManyAuthorInputEnvelope;
	set?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	disconnect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	delete?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	update?:
		| Prisma.PoemUpdateWithWhereUniqueWithoutAuthorInput
		| Prisma.PoemUpdateWithWhereUniqueWithoutAuthorInput[];
	updateMany?:
		| Prisma.PoemUpdateManyWithWhereWithoutAuthorInput
		| Prisma.PoemUpdateManyWithWhereWithoutAuthorInput[];
	deleteMany?: Prisma.PoemScalarWhereInput | Prisma.PoemScalarWhereInput[];
};

export type PoemUpdateManyWithoutToUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutToUserInput,
				Prisma.PoemUncheckedCreateWithoutToUserInput
		  >
		| Prisma.PoemCreateWithoutToUserInput[]
		| Prisma.PoemUncheckedCreateWithoutToUserInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutToUserInput
		| Prisma.PoemCreateOrConnectWithoutToUserInput[];
	upsert?:
		| Prisma.PoemUpsertWithWhereUniqueWithoutToUserInput
		| Prisma.PoemUpsertWithWhereUniqueWithoutToUserInput[];
	createMany?: Prisma.PoemCreateManyToUserInputEnvelope;
	set?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	disconnect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	delete?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	update?:
		| Prisma.PoemUpdateWithWhereUniqueWithoutToUserInput
		| Prisma.PoemUpdateWithWhereUniqueWithoutToUserInput[];
	updateMany?:
		| Prisma.PoemUpdateManyWithWhereWithoutToUserInput
		| Prisma.PoemUpdateManyWithWhereWithoutToUserInput[];
	deleteMany?: Prisma.PoemScalarWhereInput | Prisma.PoemScalarWhereInput[];
};

export type PoemUncheckedUpdateManyWithoutAuthorNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutAuthorInput,
				Prisma.PoemUncheckedCreateWithoutAuthorInput
		  >
		| Prisma.PoemCreateWithoutAuthorInput[]
		| Prisma.PoemUncheckedCreateWithoutAuthorInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutAuthorInput
		| Prisma.PoemCreateOrConnectWithoutAuthorInput[];
	upsert?:
		| Prisma.PoemUpsertWithWhereUniqueWithoutAuthorInput
		| Prisma.PoemUpsertWithWhereUniqueWithoutAuthorInput[];
	createMany?: Prisma.PoemCreateManyAuthorInputEnvelope;
	set?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	disconnect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	delete?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	update?:
		| Prisma.PoemUpdateWithWhereUniqueWithoutAuthorInput
		| Prisma.PoemUpdateWithWhereUniqueWithoutAuthorInput[];
	updateMany?:
		| Prisma.PoemUpdateManyWithWhereWithoutAuthorInput
		| Prisma.PoemUpdateManyWithWhereWithoutAuthorInput[];
	deleteMany?: Prisma.PoemScalarWhereInput | Prisma.PoemScalarWhereInput[];
};

export type PoemUncheckedUpdateManyWithoutToUserNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutToUserInput,
				Prisma.PoemUncheckedCreateWithoutToUserInput
		  >
		| Prisma.PoemCreateWithoutToUserInput[]
		| Prisma.PoemUncheckedCreateWithoutToUserInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutToUserInput
		| Prisma.PoemCreateOrConnectWithoutToUserInput[];
	upsert?:
		| Prisma.PoemUpsertWithWhereUniqueWithoutToUserInput
		| Prisma.PoemUpsertWithWhereUniqueWithoutToUserInput[];
	createMany?: Prisma.PoemCreateManyToUserInputEnvelope;
	set?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	disconnect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	delete?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	update?:
		| Prisma.PoemUpdateWithWhereUniqueWithoutToUserInput
		| Prisma.PoemUpdateWithWhereUniqueWithoutToUserInput[];
	updateMany?:
		| Prisma.PoemUpdateManyWithWhereWithoutToUserInput
		| Prisma.PoemUpdateManyWithWhereWithoutToUserInput[];
	deleteMany?: Prisma.PoemScalarWhereInput | Prisma.PoemScalarWhereInput[];
};

export type PoemCreateNestedOneWithoutCommentsInput = {
	create?: Prisma.XOR<
		Prisma.PoemCreateWithoutCommentsInput,
		Prisma.PoemUncheckedCreateWithoutCommentsInput
	>;
	connectOrCreate?: Prisma.PoemCreateOrConnectWithoutCommentsInput;
	connect?: Prisma.PoemWhereUniqueInput;
};

export type PoemUpdateOneRequiredWithoutCommentsNestedInput = {
	create?: Prisma.XOR<
		Prisma.PoemCreateWithoutCommentsInput,
		Prisma.PoemUncheckedCreateWithoutCommentsInput
	>;
	connectOrCreate?: Prisma.PoemCreateOrConnectWithoutCommentsInput;
	upsert?: Prisma.PoemUpsertWithoutCommentsInput;
	connect?: Prisma.PoemWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.PoemUpdateToOneWithWhereWithoutCommentsInput,
			Prisma.PoemUpdateWithoutCommentsInput
		>,
		Prisma.PoemUncheckedUpdateWithoutCommentsInput
	>;
};

export type PoemCreateNestedOneWithoutPoemLikesInput = {
	create?: Prisma.XOR<
		Prisma.PoemCreateWithoutPoemLikesInput,
		Prisma.PoemUncheckedCreateWithoutPoemLikesInput
	>;
	connectOrCreate?: Prisma.PoemCreateOrConnectWithoutPoemLikesInput;
	connect?: Prisma.PoemWhereUniqueInput;
};

export type PoemUpdateOneRequiredWithoutPoemLikesNestedInput = {
	create?: Prisma.XOR<
		Prisma.PoemCreateWithoutPoemLikesInput,
		Prisma.PoemUncheckedCreateWithoutPoemLikesInput
	>;
	connectOrCreate?: Prisma.PoemCreateOrConnectWithoutPoemLikesInput;
	upsert?: Prisma.PoemUpsertWithoutPoemLikesInput;
	connect?: Prisma.PoemWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.PoemUpdateToOneWithWhereWithoutPoemLikesInput,
			Prisma.PoemUpdateWithoutPoemLikesInput
		>,
		Prisma.PoemUncheckedUpdateWithoutPoemLikesInput
	>;
};

export type PoemCreateNestedOneWithoutDedicationsInput = {
	create?: Prisma.XOR<
		Prisma.PoemCreateWithoutDedicationsInput,
		Prisma.PoemUncheckedCreateWithoutDedicationsInput
	>;
	connectOrCreate?: Prisma.PoemCreateOrConnectWithoutDedicationsInput;
	connect?: Prisma.PoemWhereUniqueInput;
};

export type PoemCreateNestedManyWithoutToPoemInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutToPoemInput,
				Prisma.PoemUncheckedCreateWithoutToPoemInput
		  >
		| Prisma.PoemCreateWithoutToPoemInput[]
		| Prisma.PoemUncheckedCreateWithoutToPoemInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutToPoemInput
		| Prisma.PoemCreateOrConnectWithoutToPoemInput[];
	createMany?: Prisma.PoemCreateManyToPoemInputEnvelope;
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
};

export type PoemUncheckedCreateNestedManyWithoutToPoemInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutToPoemInput,
				Prisma.PoemUncheckedCreateWithoutToPoemInput
		  >
		| Prisma.PoemCreateWithoutToPoemInput[]
		| Prisma.PoemUncheckedCreateWithoutToPoemInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutToPoemInput
		| Prisma.PoemCreateOrConnectWithoutToPoemInput[];
	createMany?: Prisma.PoemCreateManyToPoemInputEnvelope;
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
};

export type NullableStringFieldUpdateOperationsInput = {
	set?: string | null;
};

export type BoolFieldUpdateOperationsInput = {
	set?: boolean;
};

export type EnumpoemStatusFieldUpdateOperationsInput = {
	set?: $Enums.poemStatus;
};

export type EnumpoemVisibilityFieldUpdateOperationsInput = {
	set?: $Enums.poemVisibility;
};

export type EnumpoemModerationStatusFieldUpdateOperationsInput = {
	set?: $Enums.poemModerationStatus;
};

export type PoemUpdateOneWithoutDedicationsNestedInput = {
	create?: Prisma.XOR<
		Prisma.PoemCreateWithoutDedicationsInput,
		Prisma.PoemUncheckedCreateWithoutDedicationsInput
	>;
	connectOrCreate?: Prisma.PoemCreateOrConnectWithoutDedicationsInput;
	upsert?: Prisma.PoemUpsertWithoutDedicationsInput;
	disconnect?: Prisma.PoemWhereInput | boolean;
	delete?: Prisma.PoemWhereInput | boolean;
	connect?: Prisma.PoemWhereUniqueInput;
	update?: Prisma.XOR<
		Prisma.XOR<
			Prisma.PoemUpdateToOneWithWhereWithoutDedicationsInput,
			Prisma.PoemUpdateWithoutDedicationsInput
		>,
		Prisma.PoemUncheckedUpdateWithoutDedicationsInput
	>;
};

export type PoemUpdateManyWithoutToPoemNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutToPoemInput,
				Prisma.PoemUncheckedCreateWithoutToPoemInput
		  >
		| Prisma.PoemCreateWithoutToPoemInput[]
		| Prisma.PoemUncheckedCreateWithoutToPoemInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutToPoemInput
		| Prisma.PoemCreateOrConnectWithoutToPoemInput[];
	upsert?:
		| Prisma.PoemUpsertWithWhereUniqueWithoutToPoemInput
		| Prisma.PoemUpsertWithWhereUniqueWithoutToPoemInput[];
	createMany?: Prisma.PoemCreateManyToPoemInputEnvelope;
	set?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	disconnect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	delete?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	update?:
		| Prisma.PoemUpdateWithWhereUniqueWithoutToPoemInput
		| Prisma.PoemUpdateWithWhereUniqueWithoutToPoemInput[];
	updateMany?:
		| Prisma.PoemUpdateManyWithWhereWithoutToPoemInput
		| Prisma.PoemUpdateManyWithWhereWithoutToPoemInput[];
	deleteMany?: Prisma.PoemScalarWhereInput | Prisma.PoemScalarWhereInput[];
};

export type PoemUncheckedUpdateManyWithoutToPoemNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutToPoemInput,
				Prisma.PoemUncheckedCreateWithoutToPoemInput
		  >
		| Prisma.PoemCreateWithoutToPoemInput[]
		| Prisma.PoemUncheckedCreateWithoutToPoemInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutToPoemInput
		| Prisma.PoemCreateOrConnectWithoutToPoemInput[];
	upsert?:
		| Prisma.PoemUpsertWithWhereUniqueWithoutToPoemInput
		| Prisma.PoemUpsertWithWhereUniqueWithoutToPoemInput[];
	createMany?: Prisma.PoemCreateManyToPoemInputEnvelope;
	set?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	disconnect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	delete?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	update?:
		| Prisma.PoemUpdateWithWhereUniqueWithoutToPoemInput
		| Prisma.PoemUpdateWithWhereUniqueWithoutToPoemInput[];
	updateMany?:
		| Prisma.PoemUpdateManyWithWhereWithoutToPoemInput
		| Prisma.PoemUpdateManyWithWhereWithoutToPoemInput[];
	deleteMany?: Prisma.PoemScalarWhereInput | Prisma.PoemScalarWhereInput[];
};

export type PoemCreateNestedManyWithoutTagsInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutTagsInput,
				Prisma.PoemUncheckedCreateWithoutTagsInput
		  >
		| Prisma.PoemCreateWithoutTagsInput[]
		| Prisma.PoemUncheckedCreateWithoutTagsInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutTagsInput
		| Prisma.PoemCreateOrConnectWithoutTagsInput[];
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
};

export type PoemUncheckedCreateNestedManyWithoutTagsInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutTagsInput,
				Prisma.PoemUncheckedCreateWithoutTagsInput
		  >
		| Prisma.PoemCreateWithoutTagsInput[]
		| Prisma.PoemUncheckedCreateWithoutTagsInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutTagsInput
		| Prisma.PoemCreateOrConnectWithoutTagsInput[];
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
};

export type PoemUpdateManyWithoutTagsNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutTagsInput,
				Prisma.PoemUncheckedCreateWithoutTagsInput
		  >
		| Prisma.PoemCreateWithoutTagsInput[]
		| Prisma.PoemUncheckedCreateWithoutTagsInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutTagsInput
		| Prisma.PoemCreateOrConnectWithoutTagsInput[];
	upsert?:
		| Prisma.PoemUpsertWithWhereUniqueWithoutTagsInput
		| Prisma.PoemUpsertWithWhereUniqueWithoutTagsInput[];
	set?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	disconnect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	delete?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	update?:
		| Prisma.PoemUpdateWithWhereUniqueWithoutTagsInput
		| Prisma.PoemUpdateWithWhereUniqueWithoutTagsInput[];
	updateMany?:
		| Prisma.PoemUpdateManyWithWhereWithoutTagsInput
		| Prisma.PoemUpdateManyWithWhereWithoutTagsInput[];
	deleteMany?: Prisma.PoemScalarWhereInput | Prisma.PoemScalarWhereInput[];
};

export type PoemUncheckedUpdateManyWithoutTagsNestedInput = {
	create?:
		| Prisma.XOR<
				Prisma.PoemCreateWithoutTagsInput,
				Prisma.PoemUncheckedCreateWithoutTagsInput
		  >
		| Prisma.PoemCreateWithoutTagsInput[]
		| Prisma.PoemUncheckedCreateWithoutTagsInput[];
	connectOrCreate?:
		| Prisma.PoemCreateOrConnectWithoutTagsInput
		| Prisma.PoemCreateOrConnectWithoutTagsInput[];
	upsert?:
		| Prisma.PoemUpsertWithWhereUniqueWithoutTagsInput
		| Prisma.PoemUpsertWithWhereUniqueWithoutTagsInput[];
	set?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	disconnect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	delete?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	connect?: Prisma.PoemWhereUniqueInput | Prisma.PoemWhereUniqueInput[];
	update?:
		| Prisma.PoemUpdateWithWhereUniqueWithoutTagsInput
		| Prisma.PoemUpdateWithWhereUniqueWithoutTagsInput[];
	updateMany?:
		| Prisma.PoemUpdateManyWithWhereWithoutTagsInput
		| Prisma.PoemUpdateManyWithWhereWithoutTagsInput[];
	deleteMany?: Prisma.PoemScalarWhereInput | Prisma.PoemScalarWhereInput[];
};

export type PoemCreateWithoutAuthorInput = {
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	toUser?: Prisma.UserCreateNestedOneWithoutFromPoemDedicationsInput;
	toPoem?: Prisma.PoemCreateNestedOneWithoutDedicationsInput;
	dedications?: Prisma.PoemCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagCreateNestedManyWithoutPoemsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeCreateNestedManyWithoutPoemInput;
};

export type PoemUncheckedCreateWithoutAuthorInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toUserId?: number | null;
	toPoemId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	dedications?: Prisma.PoemUncheckedCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagUncheckedCreateNestedManyWithoutPoemsInput;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeUncheckedCreateNestedManyWithoutPoemInput;
};

export type PoemCreateOrConnectWithoutAuthorInput = {
	where: Prisma.PoemWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutAuthorInput,
		Prisma.PoemUncheckedCreateWithoutAuthorInput
	>;
};

export type PoemCreateManyAuthorInputEnvelope = {
	data: Prisma.PoemCreateManyAuthorInput | Prisma.PoemCreateManyAuthorInput[];
	skipDuplicates?: boolean;
};

export type PoemCreateWithoutToUserInput = {
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	toPoem?: Prisma.PoemCreateNestedOneWithoutDedicationsInput;
	dedications?: Prisma.PoemCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagCreateNestedManyWithoutPoemsInput;
	author: Prisma.UserCreateNestedOneWithoutPoemsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeCreateNestedManyWithoutPoemInput;
};

export type PoemUncheckedCreateWithoutToUserInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toPoemId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	authorId: number;
	dedications?: Prisma.PoemUncheckedCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagUncheckedCreateNestedManyWithoutPoemsInput;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeUncheckedCreateNestedManyWithoutPoemInput;
};

export type PoemCreateOrConnectWithoutToUserInput = {
	where: Prisma.PoemWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutToUserInput,
		Prisma.PoemUncheckedCreateWithoutToUserInput
	>;
};

export type PoemCreateManyToUserInputEnvelope = {
	data: Prisma.PoemCreateManyToUserInput | Prisma.PoemCreateManyToUserInput[];
	skipDuplicates?: boolean;
};

export type PoemUpsertWithWhereUniqueWithoutAuthorInput = {
	where: Prisma.PoemWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.PoemUpdateWithoutAuthorInput,
		Prisma.PoemUncheckedUpdateWithoutAuthorInput
	>;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutAuthorInput,
		Prisma.PoemUncheckedCreateWithoutAuthorInput
	>;
};

export type PoemUpdateWithWhereUniqueWithoutAuthorInput = {
	where: Prisma.PoemWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.PoemUpdateWithoutAuthorInput,
		Prisma.PoemUncheckedUpdateWithoutAuthorInput
	>;
};

export type PoemUpdateManyWithWhereWithoutAuthorInput = {
	where: Prisma.PoemScalarWhereInput;
	data: Prisma.XOR<
		Prisma.PoemUpdateManyMutationInput,
		Prisma.PoemUncheckedUpdateManyWithoutAuthorInput
	>;
};

export type PoemScalarWhereInput = {
	AND?: Prisma.PoemScalarWhereInput | Prisma.PoemScalarWhereInput[];
	OR?: Prisma.PoemScalarWhereInput[];
	NOT?: Prisma.PoemScalarWhereInput | Prisma.PoemScalarWhereInput[];
	id?: Prisma.IntFilter<'Poem'> | number;
	title?: Prisma.StringFilter<'Poem'> | string;
	slug?: Prisma.StringFilter<'Poem'> | string;
	excerpt?: Prisma.StringNullableFilter<'Poem'> | string | null;
	content?: Prisma.StringFilter<'Poem'> | string;
	isCommentable?: Prisma.BoolFilter<'Poem'> | boolean;
	toUserId?: Prisma.IntNullableFilter<'Poem'> | number | null;
	toPoemId?: Prisma.IntNullableFilter<'Poem'> | number | null;
	status?: Prisma.EnumpoemStatusFilter<'Poem'> | $Enums.poemStatus;
	visibility?: Prisma.EnumpoemVisibilityFilter<'Poem'> | $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFilter<'Poem'>
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFilter<'Poem'> | Date | string;
	updatedAt?: Prisma.DateTimeFilter<'Poem'> | Date | string;
	deletedAt?: Prisma.DateTimeNullableFilter<'Poem'> | Date | string | null;
	authorId?: Prisma.IntFilter<'Poem'> | number;
};

export type PoemUpsertWithWhereUniqueWithoutToUserInput = {
	where: Prisma.PoemWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.PoemUpdateWithoutToUserInput,
		Prisma.PoemUncheckedUpdateWithoutToUserInput
	>;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutToUserInput,
		Prisma.PoemUncheckedCreateWithoutToUserInput
	>;
};

export type PoemUpdateWithWhereUniqueWithoutToUserInput = {
	where: Prisma.PoemWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.PoemUpdateWithoutToUserInput,
		Prisma.PoemUncheckedUpdateWithoutToUserInput
	>;
};

export type PoemUpdateManyWithWhereWithoutToUserInput = {
	where: Prisma.PoemScalarWhereInput;
	data: Prisma.XOR<
		Prisma.PoemUpdateManyMutationInput,
		Prisma.PoemUncheckedUpdateManyWithoutToUserInput
	>;
};

export type PoemCreateWithoutCommentsInput = {
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	toUser?: Prisma.UserCreateNestedOneWithoutFromPoemDedicationsInput;
	toPoem?: Prisma.PoemCreateNestedOneWithoutDedicationsInput;
	dedications?: Prisma.PoemCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagCreateNestedManyWithoutPoemsInput;
	author: Prisma.UserCreateNestedOneWithoutPoemsInput;
	poemLikes?: Prisma.PoemLikeCreateNestedManyWithoutPoemInput;
};

export type PoemUncheckedCreateWithoutCommentsInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toUserId?: number | null;
	toPoemId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	authorId: number;
	dedications?: Prisma.PoemUncheckedCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagUncheckedCreateNestedManyWithoutPoemsInput;
	poemLikes?: Prisma.PoemLikeUncheckedCreateNestedManyWithoutPoemInput;
};

export type PoemCreateOrConnectWithoutCommentsInput = {
	where: Prisma.PoemWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutCommentsInput,
		Prisma.PoemUncheckedCreateWithoutCommentsInput
	>;
};

export type PoemUpsertWithoutCommentsInput = {
	update: Prisma.XOR<
		Prisma.PoemUpdateWithoutCommentsInput,
		Prisma.PoemUncheckedUpdateWithoutCommentsInput
	>;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutCommentsInput,
		Prisma.PoemUncheckedCreateWithoutCommentsInput
	>;
	where?: Prisma.PoemWhereInput;
};

export type PoemUpdateToOneWithWhereWithoutCommentsInput = {
	where?: Prisma.PoemWhereInput;
	data: Prisma.XOR<
		Prisma.PoemUpdateWithoutCommentsInput,
		Prisma.PoemUncheckedUpdateWithoutCommentsInput
	>;
};

export type PoemUpdateWithoutCommentsInput = {
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	toUser?: Prisma.UserUpdateOneWithoutFromPoemDedicationsNestedInput;
	toPoem?: Prisma.PoemUpdateOneWithoutDedicationsNestedInput;
	dedications?: Prisma.PoemUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUpdateManyWithoutPoemsNestedInput;
	author?: Prisma.UserUpdateOneRequiredWithoutPoemsNestedInput;
	poemLikes?: Prisma.PoemLikeUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateWithoutCommentsInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toUserId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	toPoemId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	authorId?: Prisma.IntFieldUpdateOperationsInput | number;
	dedications?: Prisma.PoemUncheckedUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUncheckedUpdateManyWithoutPoemsNestedInput;
	poemLikes?: Prisma.PoemLikeUncheckedUpdateManyWithoutPoemNestedInput;
};

export type PoemCreateWithoutPoemLikesInput = {
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	toUser?: Prisma.UserCreateNestedOneWithoutFromPoemDedicationsInput;
	toPoem?: Prisma.PoemCreateNestedOneWithoutDedicationsInput;
	dedications?: Prisma.PoemCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagCreateNestedManyWithoutPoemsInput;
	author: Prisma.UserCreateNestedOneWithoutPoemsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPoemInput;
};

export type PoemUncheckedCreateWithoutPoemLikesInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toUserId?: number | null;
	toPoemId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	authorId: number;
	dedications?: Prisma.PoemUncheckedCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagUncheckedCreateNestedManyWithoutPoemsInput;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPoemInput;
};

export type PoemCreateOrConnectWithoutPoemLikesInput = {
	where: Prisma.PoemWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutPoemLikesInput,
		Prisma.PoemUncheckedCreateWithoutPoemLikesInput
	>;
};

export type PoemUpsertWithoutPoemLikesInput = {
	update: Prisma.XOR<
		Prisma.PoemUpdateWithoutPoemLikesInput,
		Prisma.PoemUncheckedUpdateWithoutPoemLikesInput
	>;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutPoemLikesInput,
		Prisma.PoemUncheckedCreateWithoutPoemLikesInput
	>;
	where?: Prisma.PoemWhereInput;
};

export type PoemUpdateToOneWithWhereWithoutPoemLikesInput = {
	where?: Prisma.PoemWhereInput;
	data: Prisma.XOR<
		Prisma.PoemUpdateWithoutPoemLikesInput,
		Prisma.PoemUncheckedUpdateWithoutPoemLikesInput
	>;
};

export type PoemUpdateWithoutPoemLikesInput = {
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	toUser?: Prisma.UserUpdateOneWithoutFromPoemDedicationsNestedInput;
	toPoem?: Prisma.PoemUpdateOneWithoutDedicationsNestedInput;
	dedications?: Prisma.PoemUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUpdateManyWithoutPoemsNestedInput;
	author?: Prisma.UserUpdateOneRequiredWithoutPoemsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateWithoutPoemLikesInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toUserId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	toPoemId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	authorId?: Prisma.IntFieldUpdateOperationsInput | number;
	dedications?: Prisma.PoemUncheckedUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUncheckedUpdateManyWithoutPoemsNestedInput;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPoemNestedInput;
};

export type PoemCreateWithoutDedicationsInput = {
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	toUser?: Prisma.UserCreateNestedOneWithoutFromPoemDedicationsInput;
	toPoem?: Prisma.PoemCreateNestedOneWithoutDedicationsInput;
	tags?: Prisma.TagCreateNestedManyWithoutPoemsInput;
	author: Prisma.UserCreateNestedOneWithoutPoemsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeCreateNestedManyWithoutPoemInput;
};

export type PoemUncheckedCreateWithoutDedicationsInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toUserId?: number | null;
	toPoemId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	authorId: number;
	tags?: Prisma.TagUncheckedCreateNestedManyWithoutPoemsInput;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeUncheckedCreateNestedManyWithoutPoemInput;
};

export type PoemCreateOrConnectWithoutDedicationsInput = {
	where: Prisma.PoemWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutDedicationsInput,
		Prisma.PoemUncheckedCreateWithoutDedicationsInput
	>;
};

export type PoemCreateWithoutToPoemInput = {
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	toUser?: Prisma.UserCreateNestedOneWithoutFromPoemDedicationsInput;
	dedications?: Prisma.PoemCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagCreateNestedManyWithoutPoemsInput;
	author: Prisma.UserCreateNestedOneWithoutPoemsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeCreateNestedManyWithoutPoemInput;
};

export type PoemUncheckedCreateWithoutToPoemInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toUserId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	authorId: number;
	dedications?: Prisma.PoemUncheckedCreateNestedManyWithoutToPoemInput;
	tags?: Prisma.TagUncheckedCreateNestedManyWithoutPoemsInput;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeUncheckedCreateNestedManyWithoutPoemInput;
};

export type PoemCreateOrConnectWithoutToPoemInput = {
	where: Prisma.PoemWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutToPoemInput,
		Prisma.PoemUncheckedCreateWithoutToPoemInput
	>;
};

export type PoemCreateManyToPoemInputEnvelope = {
	data: Prisma.PoemCreateManyToPoemInput | Prisma.PoemCreateManyToPoemInput[];
	skipDuplicates?: boolean;
};

export type PoemUpsertWithoutDedicationsInput = {
	update: Prisma.XOR<
		Prisma.PoemUpdateWithoutDedicationsInput,
		Prisma.PoemUncheckedUpdateWithoutDedicationsInput
	>;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutDedicationsInput,
		Prisma.PoemUncheckedCreateWithoutDedicationsInput
	>;
	where?: Prisma.PoemWhereInput;
};

export type PoemUpdateToOneWithWhereWithoutDedicationsInput = {
	where?: Prisma.PoemWhereInput;
	data: Prisma.XOR<
		Prisma.PoemUpdateWithoutDedicationsInput,
		Prisma.PoemUncheckedUpdateWithoutDedicationsInput
	>;
};

export type PoemUpdateWithoutDedicationsInput = {
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	toUser?: Prisma.UserUpdateOneWithoutFromPoemDedicationsNestedInput;
	toPoem?: Prisma.PoemUpdateOneWithoutDedicationsNestedInput;
	tags?: Prisma.TagUpdateManyWithoutPoemsNestedInput;
	author?: Prisma.UserUpdateOneRequiredWithoutPoemsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateWithoutDedicationsInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toUserId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	toPoemId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	authorId?: Prisma.IntFieldUpdateOperationsInput | number;
	tags?: Prisma.TagUncheckedUpdateManyWithoutPoemsNestedInput;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUncheckedUpdateManyWithoutPoemNestedInput;
};

export type PoemUpsertWithWhereUniqueWithoutToPoemInput = {
	where: Prisma.PoemWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.PoemUpdateWithoutToPoemInput,
		Prisma.PoemUncheckedUpdateWithoutToPoemInput
	>;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutToPoemInput,
		Prisma.PoemUncheckedCreateWithoutToPoemInput
	>;
};

export type PoemUpdateWithWhereUniqueWithoutToPoemInput = {
	where: Prisma.PoemWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.PoemUpdateWithoutToPoemInput,
		Prisma.PoemUncheckedUpdateWithoutToPoemInput
	>;
};

export type PoemUpdateManyWithWhereWithoutToPoemInput = {
	where: Prisma.PoemScalarWhereInput;
	data: Prisma.XOR<
		Prisma.PoemUpdateManyMutationInput,
		Prisma.PoemUncheckedUpdateManyWithoutToPoemInput
	>;
};

export type PoemCreateWithoutTagsInput = {
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	toUser?: Prisma.UserCreateNestedOneWithoutFromPoemDedicationsInput;
	toPoem?: Prisma.PoemCreateNestedOneWithoutDedicationsInput;
	dedications?: Prisma.PoemCreateNestedManyWithoutToPoemInput;
	author: Prisma.UserCreateNestedOneWithoutPoemsInput;
	comments?: Prisma.CommentCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeCreateNestedManyWithoutPoemInput;
};

export type PoemUncheckedCreateWithoutTagsInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toUserId?: number | null;
	toPoemId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	authorId: number;
	dedications?: Prisma.PoemUncheckedCreateNestedManyWithoutToPoemInput;
	comments?: Prisma.CommentUncheckedCreateNestedManyWithoutPoemInput;
	poemLikes?: Prisma.PoemLikeUncheckedCreateNestedManyWithoutPoemInput;
};

export type PoemCreateOrConnectWithoutTagsInput = {
	where: Prisma.PoemWhereUniqueInput;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutTagsInput,
		Prisma.PoemUncheckedCreateWithoutTagsInput
	>;
};

export type PoemUpsertWithWhereUniqueWithoutTagsInput = {
	where: Prisma.PoemWhereUniqueInput;
	update: Prisma.XOR<
		Prisma.PoemUpdateWithoutTagsInput,
		Prisma.PoemUncheckedUpdateWithoutTagsInput
	>;
	create: Prisma.XOR<
		Prisma.PoemCreateWithoutTagsInput,
		Prisma.PoemUncheckedCreateWithoutTagsInput
	>;
};

export type PoemUpdateWithWhereUniqueWithoutTagsInput = {
	where: Prisma.PoemWhereUniqueInput;
	data: Prisma.XOR<
		Prisma.PoemUpdateWithoutTagsInput,
		Prisma.PoemUncheckedUpdateWithoutTagsInput
	>;
};

export type PoemUpdateManyWithWhereWithoutTagsInput = {
	where: Prisma.PoemScalarWhereInput;
	data: Prisma.XOR<
		Prisma.PoemUpdateManyMutationInput,
		Prisma.PoemUncheckedUpdateManyWithoutTagsInput
	>;
};

export type PoemCreateManyAuthorInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toUserId?: number | null;
	toPoemId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
};

export type PoemCreateManyToUserInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toPoemId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	authorId: number;
};

export type PoemUpdateWithoutAuthorInput = {
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	toUser?: Prisma.UserUpdateOneWithoutFromPoemDedicationsNestedInput;
	toPoem?: Prisma.PoemUpdateOneWithoutDedicationsNestedInput;
	dedications?: Prisma.PoemUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUpdateManyWithoutPoemsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateWithoutAuthorInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toUserId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	toPoemId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	dedications?: Prisma.PoemUncheckedUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUncheckedUpdateManyWithoutPoemsNestedInput;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUncheckedUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateManyWithoutAuthorInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toUserId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	toPoemId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
};

export type PoemUpdateWithoutToUserInput = {
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	toPoem?: Prisma.PoemUpdateOneWithoutDedicationsNestedInput;
	dedications?: Prisma.PoemUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUpdateManyWithoutPoemsNestedInput;
	author?: Prisma.UserUpdateOneRequiredWithoutPoemsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateWithoutToUserInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toPoemId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	authorId?: Prisma.IntFieldUpdateOperationsInput | number;
	dedications?: Prisma.PoemUncheckedUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUncheckedUpdateManyWithoutPoemsNestedInput;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUncheckedUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateManyWithoutToUserInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toPoemId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	authorId?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type PoemCreateManyToPoemInput = {
	id?: number;
	title: string;
	slug: string;
	excerpt?: string | null;
	content: string;
	isCommentable?: boolean;
	toUserId?: number | null;
	status?: $Enums.poemStatus;
	visibility?: $Enums.poemVisibility;
	moderationStatus?: $Enums.poemModerationStatus;
	createdAt?: Date | string;
	updatedAt?: Date | string;
	deletedAt?: Date | string | null;
	authorId: number;
};

export type PoemUpdateWithoutToPoemInput = {
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	toUser?: Prisma.UserUpdateOneWithoutFromPoemDedicationsNestedInput;
	dedications?: Prisma.PoemUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUpdateManyWithoutPoemsNestedInput;
	author?: Prisma.UserUpdateOneRequiredWithoutPoemsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateWithoutToPoemInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toUserId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	authorId?: Prisma.IntFieldUpdateOperationsInput | number;
	dedications?: Prisma.PoemUncheckedUpdateManyWithoutToPoemNestedInput;
	tags?: Prisma.TagUncheckedUpdateManyWithoutPoemsNestedInput;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUncheckedUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateManyWithoutToPoemInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toUserId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	authorId?: Prisma.IntFieldUpdateOperationsInput | number;
};

export type PoemUpdateWithoutTagsInput = {
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	toUser?: Prisma.UserUpdateOneWithoutFromPoemDedicationsNestedInput;
	toPoem?: Prisma.PoemUpdateOneWithoutDedicationsNestedInput;
	dedications?: Prisma.PoemUpdateManyWithoutToPoemNestedInput;
	author?: Prisma.UserUpdateOneRequiredWithoutPoemsNestedInput;
	comments?: Prisma.CommentUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateWithoutTagsInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toUserId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	toPoemId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	authorId?: Prisma.IntFieldUpdateOperationsInput | number;
	dedications?: Prisma.PoemUncheckedUpdateManyWithoutToPoemNestedInput;
	comments?: Prisma.CommentUncheckedUpdateManyWithoutPoemNestedInput;
	poemLikes?: Prisma.PoemLikeUncheckedUpdateManyWithoutPoemNestedInput;
};

export type PoemUncheckedUpdateManyWithoutTagsInput = {
	id?: Prisma.IntFieldUpdateOperationsInput | number;
	title?: Prisma.StringFieldUpdateOperationsInput | string;
	slug?: Prisma.StringFieldUpdateOperationsInput | string;
	excerpt?: Prisma.NullableStringFieldUpdateOperationsInput | string | null;
	content?: Prisma.StringFieldUpdateOperationsInput | string;
	isCommentable?: Prisma.BoolFieldUpdateOperationsInput | boolean;
	toUserId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	toPoemId?: Prisma.NullableIntFieldUpdateOperationsInput | number | null;
	status?: Prisma.EnumpoemStatusFieldUpdateOperationsInput | $Enums.poemStatus;
	visibility?:
		| Prisma.EnumpoemVisibilityFieldUpdateOperationsInput
		| $Enums.poemVisibility;
	moderationStatus?:
		| Prisma.EnumpoemModerationStatusFieldUpdateOperationsInput
		| $Enums.poemModerationStatus;
	createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	updatedAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string;
	deletedAt?:
		| Prisma.NullableDateTimeFieldUpdateOperationsInput
		| Date
		| string
		| null;
	authorId?: Prisma.IntFieldUpdateOperationsInput | number;
};

/**
 * Count Type PoemCountOutputType
 */

export type PoemCountOutputType = {
	dedications: number;
	tags: number;
	comments: number;
	poemLikes: number;
};

export type PoemCountOutputTypeSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	dedications?: boolean | PoemCountOutputTypeCountDedicationsArgs;
	tags?: boolean | PoemCountOutputTypeCountTagsArgs;
	comments?: boolean | PoemCountOutputTypeCountCommentsArgs;
	poemLikes?: boolean | PoemCountOutputTypeCountPoemLikesArgs;
};

/**
 * PoemCountOutputType without action
 */
export type PoemCountOutputTypeDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the PoemCountOutputType
	 */
	select?: Prisma.PoemCountOutputTypeSelect<ExtArgs> | null;
};

/**
 * PoemCountOutputType without action
 */
export type PoemCountOutputTypeCountDedicationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.PoemWhereInput;
};

/**
 * PoemCountOutputType without action
 */
export type PoemCountOutputTypeCountTagsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.TagWhereInput;
};

/**
 * PoemCountOutputType without action
 */
export type PoemCountOutputTypeCountCommentsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.CommentWhereInput;
};

/**
 * PoemCountOutputType without action
 */
export type PoemCountOutputTypeCountPoemLikesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	where?: Prisma.PoemLikeWhereInput;
};

export type PoemSelect<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		title?: boolean;
		slug?: boolean;
		excerpt?: boolean;
		content?: boolean;
		isCommentable?: boolean;
		toUserId?: boolean;
		toPoemId?: boolean;
		status?: boolean;
		visibility?: boolean;
		moderationStatus?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		deletedAt?: boolean;
		authorId?: boolean;
		toUser?: boolean | Prisma.Poem$toUserArgs<ExtArgs>;
		toPoem?: boolean | Prisma.Poem$toPoemArgs<ExtArgs>;
		dedications?: boolean | Prisma.Poem$dedicationsArgs<ExtArgs>;
		tags?: boolean | Prisma.Poem$tagsArgs<ExtArgs>;
		author?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
		comments?: boolean | Prisma.Poem$commentsArgs<ExtArgs>;
		poemLikes?: boolean | Prisma.Poem$poemLikesArgs<ExtArgs>;
		_count?: boolean | Prisma.PoemCountOutputTypeDefaultArgs<ExtArgs>;
	},
	ExtArgs['result']['poem']
>;

export type PoemSelectCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		title?: boolean;
		slug?: boolean;
		excerpt?: boolean;
		content?: boolean;
		isCommentable?: boolean;
		toUserId?: boolean;
		toPoemId?: boolean;
		status?: boolean;
		visibility?: boolean;
		moderationStatus?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		deletedAt?: boolean;
		authorId?: boolean;
		toUser?: boolean | Prisma.Poem$toUserArgs<ExtArgs>;
		toPoem?: boolean | Prisma.Poem$toPoemArgs<ExtArgs>;
		author?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs['result']['poem']
>;

export type PoemSelectUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetSelect<
	{
		id?: boolean;
		title?: boolean;
		slug?: boolean;
		excerpt?: boolean;
		content?: boolean;
		isCommentable?: boolean;
		toUserId?: boolean;
		toPoemId?: boolean;
		status?: boolean;
		visibility?: boolean;
		moderationStatus?: boolean;
		createdAt?: boolean;
		updatedAt?: boolean;
		deletedAt?: boolean;
		authorId?: boolean;
		toUser?: boolean | Prisma.Poem$toUserArgs<ExtArgs>;
		toPoem?: boolean | Prisma.Poem$toPoemArgs<ExtArgs>;
		author?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	},
	ExtArgs['result']['poem']
>;

export type PoemSelectScalar = {
	id?: boolean;
	title?: boolean;
	slug?: boolean;
	excerpt?: boolean;
	content?: boolean;
	isCommentable?: boolean;
	toUserId?: boolean;
	toPoemId?: boolean;
	status?: boolean;
	visibility?: boolean;
	moderationStatus?: boolean;
	createdAt?: boolean;
	updatedAt?: boolean;
	deletedAt?: boolean;
	authorId?: boolean;
};

export type PoemOmit<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = runtime.Types.Extensions.GetOmit<
	| 'id'
	| 'title'
	| 'slug'
	| 'excerpt'
	| 'content'
	| 'isCommentable'
	| 'toUserId'
	| 'toPoemId'
	| 'status'
	| 'visibility'
	| 'moderationStatus'
	| 'createdAt'
	| 'updatedAt'
	| 'deletedAt'
	| 'authorId',
	ExtArgs['result']['poem']
>;
export type PoemInclude<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	toUser?: boolean | Prisma.Poem$toUserArgs<ExtArgs>;
	toPoem?: boolean | Prisma.Poem$toPoemArgs<ExtArgs>;
	dedications?: boolean | Prisma.Poem$dedicationsArgs<ExtArgs>;
	tags?: boolean | Prisma.Poem$tagsArgs<ExtArgs>;
	author?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
	comments?: boolean | Prisma.Poem$commentsArgs<ExtArgs>;
	poemLikes?: boolean | Prisma.Poem$poemLikesArgs<ExtArgs>;
	_count?: boolean | Prisma.PoemCountOutputTypeDefaultArgs<ExtArgs>;
};
export type PoemIncludeCreateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	toUser?: boolean | Prisma.Poem$toUserArgs<ExtArgs>;
	toPoem?: boolean | Prisma.Poem$toPoemArgs<ExtArgs>;
	author?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};
export type PoemIncludeUpdateManyAndReturn<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	toUser?: boolean | Prisma.Poem$toUserArgs<ExtArgs>;
	toPoem?: boolean | Prisma.Poem$toPoemArgs<ExtArgs>;
	author?: boolean | Prisma.UserDefaultArgs<ExtArgs>;
};

export type $PoemPayload<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	name: 'Poem';
	objects: {
		toUser: Prisma.$UserPayload<ExtArgs> | null;
		toPoem: Prisma.$PoemPayload<ExtArgs> | null;
		dedications: Prisma.$PoemPayload<ExtArgs>[];
		tags: Prisma.$TagPayload<ExtArgs>[];
		author: Prisma.$UserPayload<ExtArgs>;
		comments: Prisma.$CommentPayload<ExtArgs>[];
		poemLikes: Prisma.$PoemLikePayload<ExtArgs>[];
	};
	scalars: runtime.Types.Extensions.GetPayloadResult<
		{
			id: number;
			title: string;
			slug: string;
			excerpt: string | null;
			content: string;
			isCommentable: boolean;
			toUserId: number | null;
			toPoemId: number | null;
			status: $Enums.poemStatus;
			visibility: $Enums.poemVisibility;
			moderationStatus: $Enums.poemModerationStatus;
			createdAt: Date;
			updatedAt: Date;
			deletedAt: Date | null;
			authorId: number;
		},
		ExtArgs['result']['poem']
	>;
	composites: {};
};

export type PoemGetPayload<
	S extends boolean | null | undefined | PoemDefaultArgs,
> = runtime.Types.Result.GetResult<Prisma.$PoemPayload, S>;

export type PoemCountArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = Omit<PoemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
	select?: PoemCountAggregateInputType | true;
};

export interface PoemDelegate<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> {
	[K: symbol]: {
		types: Prisma.TypeMap<ExtArgs>['model']['Poem'];
		meta: { name: 'Poem' };
	};
	/**
	 * Find zero or one Poem that matches the filter.
	 * @param {PoemFindUniqueArgs} args - Arguments to find a Poem
	 * @example
	 * // Get one Poem
	 * const poem = await prisma.poem.findUnique({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUnique<T extends PoemFindUniqueArgs>(
		args: Prisma.SelectSubset<T, PoemFindUniqueArgs<ExtArgs>>,
	): Prisma.Prisma__PoemClient<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'findUnique',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find one Poem that matches the filter or throw an error with `error.code='P2025'`
	 * if no matches were found.
	 * @param {PoemFindUniqueOrThrowArgs} args - Arguments to find a Poem
	 * @example
	 * // Get one Poem
	 * const poem = await prisma.poem.findUniqueOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findUniqueOrThrow<T extends PoemFindUniqueOrThrowArgs>(
		args: Prisma.SelectSubset<T, PoemFindUniqueOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__PoemClient<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'findUniqueOrThrow',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Poem that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PoemFindFirstArgs} args - Arguments to find a Poem
	 * @example
	 * // Get one Poem
	 * const poem = await prisma.poem.findFirst({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirst<T extends PoemFindFirstArgs>(
		args?: Prisma.SelectSubset<T, PoemFindFirstArgs<ExtArgs>>,
	): Prisma.Prisma__PoemClient<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'findFirst',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find the first Poem that matches the filter or
	 * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PoemFindFirstOrThrowArgs} args - Arguments to find a Poem
	 * @example
	 * // Get one Poem
	 * const poem = await prisma.poem.findFirstOrThrow({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 */
	findFirstOrThrow<T extends PoemFindFirstOrThrowArgs>(
		args?: Prisma.SelectSubset<T, PoemFindFirstOrThrowArgs<ExtArgs>>,
	): Prisma.Prisma__PoemClient<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'findFirstOrThrow',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Find zero or more Poems that matches the filter.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PoemFindManyArgs} args - Arguments to filter and select certain fields only.
	 * @example
	 * // Get all Poems
	 * const poems = await prisma.poem.findMany()
	 *
	 * // Get first 10 Poems
	 * const poems = await prisma.poem.findMany({ take: 10 })
	 *
	 * // Only select the `id`
	 * const poemWithIdOnly = await prisma.poem.findMany({ select: { id: true } })
	 *
	 */
	findMany<T extends PoemFindManyArgs>(
		args?: Prisma.SelectSubset<T, PoemFindManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'findMany',
			GlobalOmitOptions
		>
	>;

	/**
	 * Create a Poem.
	 * @param {PoemCreateArgs} args - Arguments to create a Poem.
	 * @example
	 * // Create one Poem
	 * const Poem = await prisma.poem.create({
	 *   data: {
	 *     // ... data to create a Poem
	 *   }
	 * })
	 *
	 */
	create<T extends PoemCreateArgs>(
		args: Prisma.SelectSubset<T, PoemCreateArgs<ExtArgs>>,
	): Prisma.Prisma__PoemClient<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'create',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Create many Poems.
	 * @param {PoemCreateManyArgs} args - Arguments to create many Poems.
	 * @example
	 * // Create many Poems
	 * const poem = await prisma.poem.createMany({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 */
	createMany<T extends PoemCreateManyArgs>(
		args?: Prisma.SelectSubset<T, PoemCreateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Create many Poems and returns the data saved in the database.
	 * @param {PoemCreateManyAndReturnArgs} args - Arguments to create many Poems.
	 * @example
	 * // Create many Poems
	 * const poem = await prisma.poem.createManyAndReturn({
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Create many Poems and only return the `id`
	 * const poemWithIdOnly = await prisma.poem.createManyAndReturn({
	 *   select: { id: true },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	createManyAndReturn<T extends PoemCreateManyAndReturnArgs>(
		args?: Prisma.SelectSubset<T, PoemCreateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'createManyAndReturn',
			GlobalOmitOptions
		>
	>;

	/**
	 * Delete a Poem.
	 * @param {PoemDeleteArgs} args - Arguments to delete one Poem.
	 * @example
	 * // Delete one Poem
	 * const Poem = await prisma.poem.delete({
	 *   where: {
	 *     // ... filter to delete one Poem
	 *   }
	 * })
	 *
	 */
	delete<T extends PoemDeleteArgs>(
		args: Prisma.SelectSubset<T, PoemDeleteArgs<ExtArgs>>,
	): Prisma.Prisma__PoemClient<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'delete',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Update one Poem.
	 * @param {PoemUpdateArgs} args - Arguments to update one Poem.
	 * @example
	 * // Update one Poem
	 * const poem = await prisma.poem.update({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	update<T extends PoemUpdateArgs>(
		args: Prisma.SelectSubset<T, PoemUpdateArgs<ExtArgs>>,
	): Prisma.Prisma__PoemClient<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'update',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Delete zero or more Poems.
	 * @param {PoemDeleteManyArgs} args - Arguments to filter Poems to delete.
	 * @example
	 * // Delete a few Poems
	 * const { count } = await prisma.poem.deleteMany({
	 *   where: {
	 *     // ... provide filter here
	 *   }
	 * })
	 *
	 */
	deleteMany<T extends PoemDeleteManyArgs>(
		args?: Prisma.SelectSubset<T, PoemDeleteManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Poems.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PoemUpdateManyArgs} args - Arguments to update one or more rows.
	 * @example
	 * // Update many Poems
	 * const poem = await prisma.poem.updateMany({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: {
	 *     // ... provide data here
	 *   }
	 * })
	 *
	 */
	updateMany<T extends PoemUpdateManyArgs>(
		args: Prisma.SelectSubset<T, PoemUpdateManyArgs<ExtArgs>>,
	): Prisma.PrismaPromise<Prisma.BatchPayload>;

	/**
	 * Update zero or more Poems and returns the data updated in the database.
	 * @param {PoemUpdateManyAndReturnArgs} args - Arguments to update many Poems.
	 * @example
	 * // Update many Poems
	 * const poem = await prisma.poem.updateManyAndReturn({
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 *
	 * // Update zero or more Poems and only return the `id`
	 * const poemWithIdOnly = await prisma.poem.updateManyAndReturn({
	 *   select: { id: true },
	 *   where: {
	 *     // ... provide filter here
	 *   },
	 *   data: [
	 *     // ... provide data here
	 *   ]
	 * })
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 *
	 */
	updateManyAndReturn<T extends PoemUpdateManyAndReturnArgs>(
		args: Prisma.SelectSubset<T, PoemUpdateManyAndReturnArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'updateManyAndReturn',
			GlobalOmitOptions
		>
	>;

	/**
	 * Create or update one Poem.
	 * @param {PoemUpsertArgs} args - Arguments to update or create a Poem.
	 * @example
	 * // Update or create a Poem
	 * const poem = await prisma.poem.upsert({
	 *   create: {
	 *     // ... data to create a Poem
	 *   },
	 *   update: {
	 *     // ... in case it already exists, update
	 *   },
	 *   where: {
	 *     // ... the filter for the Poem we want to update
	 *   }
	 * })
	 */
	upsert<T extends PoemUpsertArgs>(
		args: Prisma.SelectSubset<T, PoemUpsertArgs<ExtArgs>>,
	): Prisma.Prisma__PoemClient<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'upsert',
			GlobalOmitOptions
		>,
		never,
		ExtArgs,
		GlobalOmitOptions
	>;

	/**
	 * Count the number of Poems.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PoemCountArgs} args - Arguments to filter Poems to count.
	 * @example
	 * // Count the number of Poems
	 * const count = await prisma.poem.count({
	 *   where: {
	 *     // ... the filter for the Poems we want to count
	 *   }
	 * })
	 **/
	count<T extends PoemCountArgs>(
		args?: Prisma.Subset<T, PoemCountArgs>,
	): Prisma.PrismaPromise<
		T extends runtime.Types.Utils.Record<'select', any>
			? T['select'] extends true
				? number
				: Prisma.GetScalarType<T['select'], PoemCountAggregateOutputType>
			: number
	>;

	/**
	 * Allows you to perform aggregations operations on a Poem.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PoemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
	 * @example
	 * // Ordered by age ascending
	 * // Where email contains prisma.io
	 * // Limited to the 10 users
	 * const aggregations = await prisma.user.aggregate({
	 *   _avg: {
	 *     age: true,
	 *   },
	 *   where: {
	 *     email: {
	 *       contains: "prisma.io",
	 *     },
	 *   },
	 *   orderBy: {
	 *     age: "asc",
	 *   },
	 *   take: 10,
	 * })
	 **/
	aggregate<T extends PoemAggregateArgs>(
		args: Prisma.Subset<T, PoemAggregateArgs>,
	): Prisma.PrismaPromise<GetPoemAggregateType<T>>;

	/**
	 * Group by Poem.
	 * Note, that providing `undefined` is treated as the value not being there.
	 * Read more here: https://pris.ly/d/null-undefined
	 * @param {PoemGroupByArgs} args - Group by arguments.
	 * @example
	 * // Group by city, order by createdAt, get count
	 * const result = await prisma.user.groupBy({
	 *   by: ['city', 'createdAt'],
	 *   orderBy: {
	 *     createdAt: true
	 *   },
	 *   _count: {
	 *     _all: true
	 *   },
	 * })
	 *
	 **/
	groupBy<
		T extends PoemGroupByArgs,
		HasSelectOrTake extends Prisma.Or<
			Prisma.Extends<'skip', Prisma.Keys<T>>,
			Prisma.Extends<'take', Prisma.Keys<T>>
		>,
		OrderByArg extends Prisma.True extends HasSelectOrTake
			? { orderBy: PoemGroupByArgs['orderBy'] }
			: { orderBy?: PoemGroupByArgs['orderBy'] },
		OrderFields extends Prisma.ExcludeUnderscoreKeys<
			Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>
		>,
		ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
		ByValid extends Prisma.Has<ByFields, OrderFields>,
		HavingFields extends Prisma.GetHavingFields<T['having']>,
		HavingValid extends Prisma.Has<ByFields, HavingFields>,
		ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
		InputErrors extends ByEmpty extends Prisma.True
			? `Error: "by" must not be empty.`
			: HavingValid extends Prisma.False
				? {
						[P in HavingFields]: P extends ByFields
							? never
							: P extends string
								? `Error: Field "${P}" used in "having" needs to be provided in "by".`
								: [
										Error,
										'Field ',
										P,
										` in "having" needs to be provided in "by"`,
									];
					}[HavingFields]
				: 'take' extends Prisma.Keys<T>
					? 'orderBy' extends Prisma.Keys<T>
						? ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields]
						: 'Error: If you provide "take", you also need to provide "orderBy"'
					: 'skip' extends Prisma.Keys<T>
						? 'orderBy' extends Prisma.Keys<T>
							? ByValid extends Prisma.True
								? {}
								: {
										[P in OrderFields]: P extends ByFields
											? never
											: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
									}[OrderFields]
							: 'Error: If you provide "skip", you also need to provide "orderBy"'
						: ByValid extends Prisma.True
							? {}
							: {
									[P in OrderFields]: P extends ByFields
										? never
										: `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
								}[OrderFields],
	>(
		args: Prisma.SubsetIntersection<T, PoemGroupByArgs, OrderByArg> &
			InputErrors,
	): {} extends InputErrors
		? GetPoemGroupByPayload<T>
		: Prisma.PrismaPromise<InputErrors>;
	/**
	 * Fields of the Poem model
	 */
	readonly fields: PoemFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Poem.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__PoemClient<
	T,
	Null = never,
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
	GlobalOmitOptions = {},
> extends Prisma.PrismaPromise<T> {
	readonly [Symbol.toStringTag]: 'PrismaPromise';
	toUser<T extends Prisma.Poem$toUserArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Poem$toUserArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		runtime.Types.Result.GetResult<
			Prisma.$UserPayload<ExtArgs>,
			T,
			'findUniqueOrThrow',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;
	toPoem<T extends Prisma.Poem$toPoemArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Poem$toPoemArgs<ExtArgs>>,
	): Prisma.Prisma__PoemClient<
		runtime.Types.Result.GetResult<
			Prisma.$PoemPayload<ExtArgs>,
			T,
			'findUniqueOrThrow',
			GlobalOmitOptions
		> | null,
		null,
		ExtArgs,
		GlobalOmitOptions
	>;
	dedications<T extends Prisma.Poem$dedicationsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Poem$dedicationsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$PoemPayload<ExtArgs>,
				T,
				'findMany',
				GlobalOmitOptions
		  >
		| Null
	>;
	tags<T extends Prisma.Poem$tagsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Poem$tagsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$TagPayload<ExtArgs>,
				T,
				'findMany',
				GlobalOmitOptions
		  >
		| Null
	>;
	author<T extends Prisma.UserDefaultArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.UserDefaultArgs<ExtArgs>>,
	): Prisma.Prisma__UserClient<
		| runtime.Types.Result.GetResult<
				Prisma.$UserPayload<ExtArgs>,
				T,
				'findUniqueOrThrow',
				GlobalOmitOptions
		  >
		| Null,
		Null,
		ExtArgs,
		GlobalOmitOptions
	>;
	comments<T extends Prisma.Poem$commentsArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Poem$commentsArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$CommentPayload<ExtArgs>,
				T,
				'findMany',
				GlobalOmitOptions
		  >
		| Null
	>;
	poemLikes<T extends Prisma.Poem$poemLikesArgs<ExtArgs> = {}>(
		args?: Prisma.Subset<T, Prisma.Poem$poemLikesArgs<ExtArgs>>,
	): Prisma.PrismaPromise<
		| runtime.Types.Result.GetResult<
				Prisma.$PoemLikePayload<ExtArgs>,
				T,
				'findMany',
				GlobalOmitOptions
		  >
		| Null
	>;
	/**
	 * Attaches callbacks for the resolution and/or rejection of the Promise.
	 * @param onfulfilled The callback to execute when the Promise is resolved.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of which ever callback is executed.
	 */
	then<TResult1 = T, TResult2 = never>(
		onfulfilled?:
			| ((value: T) => TResult1 | PromiseLike<TResult1>)
			| undefined
			| null,
		onrejected?:
			| ((reason: any) => TResult2 | PromiseLike<TResult2>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<TResult1 | TResult2>;
	/**
	 * Attaches a callback for only the rejection of the Promise.
	 * @param onrejected The callback to execute when the Promise is rejected.
	 * @returns A Promise for the completion of the callback.
	 */
	catch<TResult = never>(
		onrejected?:
			| ((reason: any) => TResult | PromiseLike<TResult>)
			| undefined
			| null,
	): runtime.Types.Utils.JsPromise<T | TResult>;
	/**
	 * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
	 * resolved value cannot be modified from the callback.
	 * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
	 * @returns A Promise for the completion of the callback.
	 */
	finally(
		onfinally?: (() => void) | undefined | null,
	): runtime.Types.Utils.JsPromise<T>;
}

/**
 * Fields of the Poem model
 */
export interface PoemFieldRefs {
	readonly id: Prisma.FieldRef<'Poem', 'Int'>;
	readonly title: Prisma.FieldRef<'Poem', 'String'>;
	readonly slug: Prisma.FieldRef<'Poem', 'String'>;
	readonly excerpt: Prisma.FieldRef<'Poem', 'String'>;
	readonly content: Prisma.FieldRef<'Poem', 'String'>;
	readonly isCommentable: Prisma.FieldRef<'Poem', 'Boolean'>;
	readonly toUserId: Prisma.FieldRef<'Poem', 'Int'>;
	readonly toPoemId: Prisma.FieldRef<'Poem', 'Int'>;
	readonly status: Prisma.FieldRef<'Poem', 'poemStatus'>;
	readonly visibility: Prisma.FieldRef<'Poem', 'poemVisibility'>;
	readonly moderationStatus: Prisma.FieldRef<'Poem', 'poemModerationStatus'>;
	readonly createdAt: Prisma.FieldRef<'Poem', 'DateTime'>;
	readonly updatedAt: Prisma.FieldRef<'Poem', 'DateTime'>;
	readonly deletedAt: Prisma.FieldRef<'Poem', 'DateTime'>;
	readonly authorId: Prisma.FieldRef<'Poem', 'Int'>;
}

// Custom InputTypes
/**
 * Poem findUnique
 */
export type PoemFindUniqueArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
	/**
	 * Filter, which Poem to fetch.
	 */
	where: Prisma.PoemWhereUniqueInput;
};

/**
 * Poem findUniqueOrThrow
 */
export type PoemFindUniqueOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
	/**
	 * Filter, which Poem to fetch.
	 */
	where: Prisma.PoemWhereUniqueInput;
};

/**
 * Poem findFirst
 */
export type PoemFindFirstArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
	/**
	 * Filter, which Poem to fetch.
	 */
	where?: Prisma.PoemWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Poems to fetch.
	 */
	orderBy?:
		| Prisma.PoemOrderByWithRelationInput
		| Prisma.PoemOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Poems.
	 */
	cursor?: Prisma.PoemWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Poems from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Poems.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Poems.
	 */
	distinct?: Prisma.PoemScalarFieldEnum | Prisma.PoemScalarFieldEnum[];
};

/**
 * Poem findFirstOrThrow
 */
export type PoemFindFirstOrThrowArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
	/**
	 * Filter, which Poem to fetch.
	 */
	where?: Prisma.PoemWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Poems to fetch.
	 */
	orderBy?:
		| Prisma.PoemOrderByWithRelationInput
		| Prisma.PoemOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for searching for Poems.
	 */
	cursor?: Prisma.PoemWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Poems from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Poems.
	 */
	skip?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
	 *
	 * Filter by unique combinations of Poems.
	 */
	distinct?: Prisma.PoemScalarFieldEnum | Prisma.PoemScalarFieldEnum[];
};

/**
 * Poem findMany
 */
export type PoemFindManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
	/**
	 * Filter, which Poems to fetch.
	 */
	where?: Prisma.PoemWhereInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
	 *
	 * Determine the order of Poems to fetch.
	 */
	orderBy?:
		| Prisma.PoemOrderByWithRelationInput
		| Prisma.PoemOrderByWithRelationInput[];
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
	 *
	 * Sets the position for listing Poems.
	 */
	cursor?: Prisma.PoemWhereUniqueInput;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Take `Â±n` Poems from the position of the cursor.
	 */
	take?: number;
	/**
	 * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
	 *
	 * Skip the first `n` Poems.
	 */
	skip?: number;
	distinct?: Prisma.PoemScalarFieldEnum | Prisma.PoemScalarFieldEnum[];
};

/**
 * Poem create
 */
export type PoemCreateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
	/**
	 * The data needed to create a Poem.
	 */
	data: Prisma.XOR<Prisma.PoemCreateInput, Prisma.PoemUncheckedCreateInput>;
};

/**
 * Poem createMany
 */
export type PoemCreateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to create many Poems.
	 */
	data: Prisma.PoemCreateManyInput | Prisma.PoemCreateManyInput[];
	skipDuplicates?: boolean;
};

/**
 * Poem createManyAndReturn
 */
export type PoemCreateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelectCreateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * The data used to create many Poems.
	 */
	data: Prisma.PoemCreateManyInput | Prisma.PoemCreateManyInput[];
	skipDuplicates?: boolean;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemIncludeCreateManyAndReturn<ExtArgs> | null;
};

/**
 * Poem update
 */
export type PoemUpdateArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
	/**
	 * The data needed to update a Poem.
	 */
	data: Prisma.XOR<Prisma.PoemUpdateInput, Prisma.PoemUncheckedUpdateInput>;
	/**
	 * Choose, which Poem to update.
	 */
	where: Prisma.PoemWhereUniqueInput;
};

/**
 * Poem updateMany
 */
export type PoemUpdateManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * The data used to update Poems.
	 */
	data: Prisma.XOR<
		Prisma.PoemUpdateManyMutationInput,
		Prisma.PoemUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Poems to update
	 */
	where?: Prisma.PoemWhereInput;
	/**
	 * Limit how many Poems to update.
	 */
	limit?: number;
};

/**
 * Poem updateManyAndReturn
 */
export type PoemUpdateManyAndReturnArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelectUpdateManyAndReturn<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * The data used to update Poems.
	 */
	data: Prisma.XOR<
		Prisma.PoemUpdateManyMutationInput,
		Prisma.PoemUncheckedUpdateManyInput
	>;
	/**
	 * Filter which Poems to update
	 */
	where?: Prisma.PoemWhereInput;
	/**
	 * Limit how many Poems to update.
	 */
	limit?: number;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemIncludeUpdateManyAndReturn<ExtArgs> | null;
};

/**
 * Poem upsert
 */
export type PoemUpsertArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
	/**
	 * The filter to search for the Poem to update in case it exists.
	 */
	where: Prisma.PoemWhereUniqueInput;
	/**
	 * In case the Poem found by the `where` argument doesn't exist, create a new Poem with this data.
	 */
	create: Prisma.XOR<Prisma.PoemCreateInput, Prisma.PoemUncheckedCreateInput>;
	/**
	 * In case the Poem was found with the provided `where` argument, update it with this data.
	 */
	update: Prisma.XOR<Prisma.PoemUpdateInput, Prisma.PoemUncheckedUpdateInput>;
};

/**
 * Poem delete
 */
export type PoemDeleteArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
	/**
	 * Filter which Poem to delete.
	 */
	where: Prisma.PoemWhereUniqueInput;
};

/**
 * Poem deleteMany
 */
export type PoemDeleteManyArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Filter which Poems to delete
	 */
	where?: Prisma.PoemWhereInput;
	/**
	 * Limit how many Poems to delete.
	 */
	limit?: number;
};

/**
 * Poem.toUser
 */
export type Poem$toUserArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the User
	 */
	select?: Prisma.UserSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the User
	 */
	omit?: Prisma.UserOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.UserInclude<ExtArgs> | null;
	where?: Prisma.UserWhereInput;
};

/**
 * Poem.toPoem
 */
export type Poem$toPoemArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
	where?: Prisma.PoemWhereInput;
};

/**
 * Poem.dedications
 */
export type Poem$dedicationsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
	where?: Prisma.PoemWhereInput;
	orderBy?:
		| Prisma.PoemOrderByWithRelationInput
		| Prisma.PoemOrderByWithRelationInput[];
	cursor?: Prisma.PoemWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.PoemScalarFieldEnum | Prisma.PoemScalarFieldEnum[];
};

/**
 * Poem.tags
 */
export type Poem$tagsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Tag
	 */
	select?: Prisma.TagSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Tag
	 */
	omit?: Prisma.TagOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.TagInclude<ExtArgs> | null;
	where?: Prisma.TagWhereInput;
	orderBy?:
		| Prisma.TagOrderByWithRelationInput
		| Prisma.TagOrderByWithRelationInput[];
	cursor?: Prisma.TagWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.TagScalarFieldEnum | Prisma.TagScalarFieldEnum[];
};

/**
 * Poem.comments
 */
export type Poem$commentsArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Comment
	 */
	select?: Prisma.CommentSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Comment
	 */
	omit?: Prisma.CommentOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.CommentInclude<ExtArgs> | null;
	where?: Prisma.CommentWhereInput;
	orderBy?:
		| Prisma.CommentOrderByWithRelationInput
		| Prisma.CommentOrderByWithRelationInput[];
	cursor?: Prisma.CommentWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.CommentScalarFieldEnum | Prisma.CommentScalarFieldEnum[];
};

/**
 * Poem.poemLikes
 */
export type Poem$poemLikesArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the PoemLike
	 */
	select?: Prisma.PoemLikeSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the PoemLike
	 */
	omit?: Prisma.PoemLikeOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemLikeInclude<ExtArgs> | null;
	where?: Prisma.PoemLikeWhereInput;
	orderBy?:
		| Prisma.PoemLikeOrderByWithRelationInput
		| Prisma.PoemLikeOrderByWithRelationInput[];
	cursor?: Prisma.PoemLikeWhereUniqueInput;
	take?: number;
	skip?: number;
	distinct?: Prisma.PoemLikeScalarFieldEnum | Prisma.PoemLikeScalarFieldEnum[];
};

/**
 * Poem without action
 */
export type PoemDefaultArgs<
	ExtArgs extends
		runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs,
> = {
	/**
	 * Select specific fields to fetch from the Poem
	 */
	select?: Prisma.PoemSelect<ExtArgs> | null;
	/**
	 * Omit specific fields from the Poem
	 */
	omit?: Prisma.PoemOmit<ExtArgs> | null;
	/**
	 * Choose, which related nodes to fetch as well
	 */
	include?: Prisma.PoemInclude<ExtArgs> | null;
};
