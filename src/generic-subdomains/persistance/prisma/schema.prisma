generator client {
  provider = "prisma-client"
  output   = "generated"
}

datasource db {
  provider = "postgresql"
}

model User {
  id           Int    @id @default(autoincrement())
  email        String @unique
  passwordHash String
  name         String
  nickname     String @unique
  bio          String
  avatarUrl    String

  role   userRole   @default(user)
  status userStatus @default(active)

  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  deletedAt       DateTime?
  emailVerifiedAt DateTime?

  poems           Poem[]
  comments        Comment[]
  commentLikes    CommentLike[]
  poemLikes       PoemLike[]
  friendshipsFrom Friendship[]  @relation("FriendshipUserA")
  friendshipsTo   Friendship[]  @relation("FriendshipUserB")

  fromPoemDedications Poem[] @relation("PoemToUserDedications")

  userSanctions UserSanction[] @relation("ModeratorSanctions")
  sanctions     UserSanction[] @relation("SanctionedUser")

  friendshipRequests   FriendshipRequest[] @relation("FriendshipRequestRequester")
  friendshipAddressees FriendshipRequest[] @relation("FriendshipRequestAddressee")

  blockedBy BlockedFriend[] @relation("BlockedByUser")

  blockedFriends BlockedFriend[] @relation("BlockedUser")
}

enum userRole {
  user
  author
  moderator
}

enum userStatus {
  active
  banned
  suspended
}

// Should be careful with the order of userAId and userBId to avoid duplicates
model Friendship {
  id        Int      @id @default(autoincrement())
  userAId   Int
  userBId   Int
  createdAt DateTime @default(now())

  userA User @relation("FriendshipUserA", fields: [userAId], references: [id])
  userB User @relation("FriendshipUserB", fields: [userBId], references: [id])

  @@unique([userAId, userBId])
}

model FriendshipRequest {
  id          Int      @id @default(autoincrement())
  requesterId Int
  addresseeId Int
  createdAt   DateTime @default(now())

  requester User @relation("FriendshipRequestRequester", fields: [requesterId], references: [id])
  addressee User @relation("FriendshipRequestAddressee", fields: [addresseeId], references: [id])

  @@unique([requesterId, addresseeId])
}

model BlockedFriend {
  id        Int      @id @default(autoincrement())
  blockerId Int
  blockedId Int
  createdAt DateTime @default(now())

  blocker User @relation("BlockedByUser", fields: [blockerId], references: [id])
  blocked User @relation("BlockedUser", fields: [blockedId], references: [id])

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

model Comment {
  id      Int    @id @default(autoincrement())
  content String

  createdAt DateTime      @default(now())
  status    commentStatus @default(visible)

  authorId Int
  author   User      @relation(fields: [authorId], references: [id])
  poemId   Int
  poem     Poem      @relation(fields: [poemId], references: [id])
  parentId Int?
  parent   Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies  Comment[] @relation("CommentReplies")

  likesRelation CommentLike[]

  @@index([poemId])
  @@index([parentId])
  @@index([authorId])
}

enum commentStatus {
  visible
  deletedByAuthor
  deletedByModerator
}

model CommentLike {
  userId    Int
  commentId Int
  createdAt DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id])
  comment Comment @relation(fields: [commentId], references: [id])

  @@id([userId, commentId])
  @@index([commentId])
}

model PoemLike {
  userId    Int
  poemId    Int
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
  poem Poem @relation(fields: [poemId], references: [id])

  @@id([userId, poemId])
}

model Poem {
  id            Int     @id @default(autoincrement())
  title         String
  slug          String
  excerpt       String?
  content       String
  isCommentable Boolean @default(true)

  toUserId Int?
  toUser   User? @relation("PoemToUserDedications", fields: [toUserId], references: [id])

  toPoemId    Int?
  toPoem      Poem?  @relation("PoemToPoemDedications", fields: [toPoemId], references: [id])
  dedications Poem[] @relation("PoemToPoemDedications")

  status           poemStatus           @default(published)
  visibility       poemVisibility       @default(public)
  moderationStatus poemModerationStatus @default(approved)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  authorId  Int
  tags      Tag[]
  author    User       @relation(fields: [authorId], references: [id])
  comments  Comment[]
  poemLikes PoemLike[]

  @@unique([authorId, slug])
  @@index([createdAt])
  @@index([authorId])
  @@index([status, visibility])
}

model Tag {
  id   Int    @id @default(autoincrement())
  name String @unique

  poems Poem[]
}

enum poemStatus {
  draft
  published
  scheduled
}

enum poemVisibility {
  public
  private
  unlisted
  friends
}

enum poemModerationStatus {
  pending
  approved
  rejected
  removed
}

model UserSanction {
  id          Int          @id @default(autoincrement())
  userId      Int
  type        SanctionType
  reason      String
  startAt     DateTime     @default(now())
  endAt       DateTime? // null means permanent sanction
  moderatorId Int

  user      User @relation("SanctionedUser", fields: [userId], references: [id])
  moderator User @relation("ModeratorSanctions", fields: [moderatorId], references: [id])

  @@index([userId])
  @@index([startAt])
}

enum SanctionType {
  suspension
  ban
}
